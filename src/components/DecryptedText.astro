---
interface Props {
  text: string;
  className?: string;
  speed?: number;
  delay?: number;
}

const { text, className = '', speed = 50, delay = 0 } = Astro.props;

// Use only alphanumeric chars for consistent widths in monospace fonts
const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
const CHARSET_LENGTH = CHARSET.length;

function tokenizeText(text: string): { word: string; startIndex: number }[] {
  const tokens: { word: string; startIndex: number }[] = [];
  let currentWord = '';
  let wordStart = 0;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === ' ') {
      if (currentWord) {
        tokens.push({ word: currentWord, startIndex: wordStart });
        currentWord = '';
      }
      tokens.push({ word: ' ', startIndex: i });
    } else {
      if (!currentWord) {
        wordStart = i;
      }
      currentWord += char;
    }
  }
  if (currentWord) {
    tokens.push({ word: currentWord, startIndex: wordStart });
  }
  return tokens;
}

const tokens = tokenizeText(text);
---

<span class={`decrypted-text-container ${className}`} data-speed={speed} data-delay={delay}>
  {tokens.map((token, tokenIndex) => {
    if (token.word === ' ') {
      return <span class="ws"> </span>;
    }
    return (
      <span class="word" style="white-space: nowrap;">
        {token.word.split('').map((char, charIndex) => (
          <span
            class="char revealed"
            style="display: inline-block;"
            data-char={char}
            data-index={token.startIndex + charIndex}
          >
            {char}
          </span>
        ))}
      </span>
    );
  })}
</span>

<script>
  // Define CHARSET inside the script explicitly to avoid sharing scope issues if bundler behaves strictly
  const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const CHARSET_LENGTH = CHARSET.length;
  const getRandomChar = () => CHARSET[Math.floor(Math.random() * CHARSET_LENGTH)];

  class DecryptedText extends HTMLElement {
    constructor() {
      super();
      // Wait for the element to be available in the DOM
      // For Astro, connection is usually immediate
    }

    connectedCallback() {
      const container = this.querySelector('.decrypted-text-container');
      if (!container) return; // Should not happen if structure matches

      const speed = Number(container.getAttribute('data-speed') || 50);
      const delay = Number(container.getAttribute('data-delay') || 0);
      
      const charElements = Array.from(container.querySelectorAll('.char')) as HTMLElement[];
      const totalChars = charElements.length;

      // Initial state: fully revealed (SSR/No-JS fallback)
      // We want to hide/scramble them and start revealing
      
      let revealedCount = 0;
      let currentIndex = 0;
      let lastUpdate = -Infinity;
      let rafId: number | null = null;
      let timeoutId: number | null = null;

      // Initialize state: all "encrypting"
      charElements.forEach(el => {
        el.classList.remove('revealed');
        el.classList.add('encrypting');
        el.textContent = getRandomChar();
      });

      const animate = (timestamp: number) => {
        if (timestamp - lastUpdate >= speed) {
            lastUpdate = timestamp;
            
            // Increment the index of revealed characters
            if (currentIndex < totalChars) {
                currentIndex++;
                revealedCount = currentIndex;
            }
        }

        // Update DOM
        charElements.forEach((el, i) => {
             const originalChar = el.getAttribute('data-char') || '';
             
             if (i < revealedCount) {
                 // Revealed state
                 if (!el.classList.contains('revealed')) {
                     el.textContent = originalChar;
                     el.classList.remove('encrypting');
                     el.classList.add('revealed');
                 }
             } else {
                 // Encrypting state calling random char
                 el.textContent = getRandomChar();
                 if (!el.classList.contains('encrypting')) {
                     el.classList.remove('revealed');
                     el.classList.add('encrypting');
                 }
             }
        });

        if (currentIndex < totalChars) {
            rafId = requestAnimationFrame(animate);
        } else {
            // Ensure final state is clean
             charElements.forEach(el => {
                 el.textContent = el.getAttribute('data-char');
                 el.classList.add('revealed');
                 el.classList.remove('encrypting');
             });
        }
      };

      timeoutId = setTimeout(() => {
        rafId = requestAnimationFrame(animate);
      }, delay);

      // Cleanup if disconnected (optional but good practice)
      // Since this is just a script tag in Astro (not a custom element definition yet, 
      // wait, I can make it just run on the selected elements)
    }
  }
  
  // To avoid defining a custom element globally which might conflict if multiple instances
  // I will just use a querySelectorAll approach in a module script.
</script>

<script>
    const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const CHARSET_LENGTH = CHARSET.length;
    const getRandomChar = () => CHARSET[Math.floor(Math.random() * CHARSET_LENGTH)];

    function initDecryptedText(container: Element) {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const speed = Number(container.getAttribute('data-speed') || 50);
      const delay = Number(container.getAttribute('data-delay') || 0);
      
      const charElements = Array.from(container.querySelectorAll('.char')) as HTMLElement[];
      const totalChars = charElements.length;

      let currentIndex = 0;
      let lastUpdate = -Infinity;
      let rafId: number;

      // Set initial scrambled state immediately
      charElements.forEach(el => {
        el.classList.remove('revealed');
        el.classList.add('encrypting');
        el.textContent = getRandomChar();
      });

      const animate = (timestamp: number) => {
          if (timestamp - lastUpdate >= speed) {
              lastUpdate = timestamp;
              if (currentIndex < totalChars) {
                  currentIndex++;
              }
          }

          // Randomize unrevealed characters on every frame (or every update?)
          // The React version randomizes unrevealed characters on every render/frame if they aren't revealed.
          // Let's randomize all unrevealed characters every frame.
          
          charElements.forEach((el, index) => {
              if (index < currentIndex) {
                  // Reveal
                  const original = el.getAttribute('data-char');
                  if (el.textContent !== original) {
                      el.textContent = original;
                      el.classList.remove('encrypting');
                      el.classList.add('revealed');
                  }
              } else {
                  // Scramble
                  el.textContent = getRandomChar();
              }
          });

          if (currentIndex < totalChars) {
              rafId = requestAnimationFrame(animate);
          }
      };

      setTimeout(() => {
          rafId = requestAnimationFrame(animate);
      }, delay);
    }

    // Run on load
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.decrypted-text-container').forEach(initDecryptedText);
    });

    // Run on Astro page navigation (if ViewTransitions were used, though user isn't using them yet, good future proofing)
    document.addEventListener('astro:page-load', () => {
        document.querySelectorAll('.decrypted-text-container').forEach(initDecryptedText);
    });
</script>
